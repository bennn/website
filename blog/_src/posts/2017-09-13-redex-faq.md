    Title: PLT Redex FAQ
    Date: 2017-09-13T01:26:46
    Tags: tutorial, PLT Redex, by Ben Greenman

A short guide to Redex concepts, conventions, and common mistakes.


<!-- more -->

<!-- TODO careful about "set" "syntactic category" etc. -->
<!-- TODO careful capitalization -->

### What is Redex useful for?

1. declaring [regular tree grammars](https://en.wikipedia.org/wiki/Regular_tree_grammar)
2. defining _pattern_-based judgments and relations on _terms_
3. testing properties of the above

More generally, Redex is helpful for experimenting with a programming language
 design, and helping you decide what you might want to prove about a language.
TODO


### What is Redex **not** useful for?

Proving theorems about a grammar, judgment, or relation.


### What is a _term_?

Informally, a term is:

- a Redex "atom", or
- an object that represents a sequence of characters.

More formally, a term is the result of evaluating `(term X)`, where `X` is
 any Racket expression.

Examples:

```
$ racket
Welcome to Racket v6.10.0.3.
> (require redex/reduction-semantics)
> (term 42)
42
> (term (+ 2 2))
'(+ 2 2)
> (term ("hello" world (#false)))
'("hello" world (#f))
```

Some terms may look strange.
That's OK, because a term by itself has no meaning.
A term is just "a Redex atom".


### What is a _Redex model_?

A Redex model is collection of tools for working with terms.
The tools may include:

- _languages_, for defining a grammar for terms
- _judgments_, for describing properties of terms or relations between terms
- _metafunctions_, for transforming terms

The goal of these tools is to encode a "real thing" (maybe, a programming language)
 using Redex terms.


### What is a language?

A Redex _language_ is a named set of non-terminals, _patterns_, and _binding forms_.
For example, here is language for natural numbers:

```
(define-language nat
  [N ::= Zero
         (Plus1 N)])
```
- the name of the language is `nat`
- the non-terminal `N` is associated with two patterns: `Zero` and `(Plus1 N)`
- there are no _binding forms_

Each pattern describes a syntactic category of terms.
Each non-terminal gives a name to the union of patterns that follow it.

The non-terminal `N` describes all terms that are either:

1. the symbol `Zero`
2. lists of the form `(Plus1 N)`, where `N` is either `Zero` or another "Plus1"

For example,

```
(term Zero)
(term (Plus1 Zero))
(term (Plus1 (Plus1 Zero)))
(term (Plus1 (Plus1 (Plus1 Zero))))
;; .... and so on
```

If a language has binding forms, then some terms can introduce names.
See the FAQ entry on _binding forms_ for an example.


### What is a pattern?

A pattern is a sequence of characters and variables.
If you have: (1) a language `L`, and (2) a pattern that contains _named non-terminals_ from `L`,
 then you can ask whether a Redex term matches the pattern.

If the term `t matches the pattern, then Redex can show how the _named non-terminals_
 in the pattern match sub-terms of `t`.

For example, `(redex-match? L p t)` returns `#true` if the term `t` matches
 the pattern `p` relative to the language `L`.

```
(define-language nat
  [N ::= Zero (Plus1 N)])

(redex-match? nat N_0 (term Zero))
;; #true
(redex-match? nat (Plus1 N_0) (term Zero))
;; #false
(redex-match? nat (Plus1 N_0) (term (Plus1 (Plus1 Zero))))
;; #true
```

If `(redex-match? L p t)` is `#true`, then `(redex-match L p t)` shows how
 the term and pattern match, with respect to the named non-terminals:

```
(redex-match nat N_0 (term Zero))
;; (list (match (list (bind 'N_0 'Zero))))
(redex-match nat (Plus1 N_0) (term Zero))
;; #f
(redex-match nat (Plus1 N_0) (term (Plus1 (Plus1 Zero))))
;; (list (match (list (bind 'N_0 '(Plus1 Zero)))))
```


#### What is a named non-terminal?

A named non-terminal in a language `L` is an identifier of the form `X_Y`, where:

- `X` is a non-terminal from `L`
- `Y` is any identifier

The name helps when one pattern contains multiple occurrences of the same non-terminal.

```
(define-language trees
  [binary-tree ::= Leaf
                   (Node binary-tree binary-tree)])

(redex-match trees
  (Node binary-tree_left binary-tree_right)
  (term (Node Leaf (Node Leaf Leaf))))
;; (list
;;  (match
;;   (list (bind 'binary-tree_left 'Leaf)
;;         (bind 'binary-tree_right '(Node Leaf Leaf)))))
```


#### What is `_` ? What is `...` ?

Patterns can contain special characters.


### What is a judgment?

### What is a metafunction?

### Mode Spec, how affects binding



### What is "Racket mode"? What is "Redex mode"?

### ... side-condition ... racket-mode ... correct argument ..





### What is a binding form?

In the lambda calculus, `λ`-terms bind variables.
A term `(λ x M)` means that any free occurrence of `x` in the sub-term `M`
 refers to the `x` from the `λ`-term.

Redex can express this idea with a binding form.

```
(define-language Λ
  [V ::= x (λ x M)]
  [M ::= (M M) V]
  [x ::= variable-not-otherwise-mentioned]
  #:binding-forms
  (λ x_0 M_0 #:refers-to x_0))
```

Binding forms work together with Redex's functions for substitution and
 alphabetic equivalence.

```
(alpha-equivalent? Λ
  (term (λ x x))
  (term (λ y y)))
;; #true

(define-metafunction Λ
  test-substitute : M -> M
  [(test-substitute (λ x_0 M_0))
   (substitute M_0 x_0 y)])
(term (test-substitute (λ z (z z))))
;; '(y y)
```


### Where to learn more about Redex?

"Critical path" resources:

- Redex documentation: <http://docs.racket-lang.org/redex/index.html>
- Source code: <https://github.com/racket/redex>
- Tutorial: <https://dvanhorn.github.io/redex-aam-tutorial/>


"Procrastination" resources:

- Tree Automata: <http://tata.gforge.inria.fr/>
- _Should your Specification Language be Typed?_: <http://lamport.azurewebsites.net/pubs/lamport-types.pdf>
- Contribute to this FAQ: TODO

<!-- https://github.com/nuprl/website/tree/master/blog/_src/posts -->
